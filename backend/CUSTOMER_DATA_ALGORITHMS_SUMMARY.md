# Алгоритмы извлечения данных покупателей из 1С

Этот документ описывает правильные алгоритмы для извлечения данных покупателей из 1С OData API, проверенные на тестовом скрипте `test_customer_data.py`.

## 1. Извлечение города покупателя

### Приоритет 1: Поле "ОсновныеСведения"
- Формат: многострочный текст
- Структура:
  ```
  Михайлова Дугма
  +79787566405
  Симферополь
  ```
- **Город находится на 3-й строке (индекс 2)**

### Приоритет 2: Структура адреса
- Поле: `Состав` → `АдресРФ` → `Улица`
- Альтернативные пути:
  - `Адрес` → `АдресРФ` → `Улица`
  - `Address` → `Город`

### Приоритет 3: Прямые поля
- `Город`
- `City`
- `НаселенныйПункт`

### Реализация:
```python
city = None
основные_сведения = customer_data.get("ОсновныеСведения")
if основные_сведения:
    if isinstance(основные_сведения, str):
        lines = основные_сведения.strip().split('\n')
        if len(lines) >= 3:
            city = lines[2].strip()
    elif isinstance(основные_сведения, list) and len(основные_сведения) >= 3:
        city = str(основные_сведения[2]).strip()

if not city:
    # Пробуем структуру адреса...
    # Пробуем прямые поля...
```

## 2. Расчет остатка бонусных баллов

### Источник данных
- Регистр: `AccumulationRegister_БонусныеБаллы_RecordType`
- Поле: **`КСписанию`** (К списанию)

### Алгоритм:
1. Получить записи, отсортированные по `Period desc`
2. Взять последнюю запись (самую свежую)
3. Значение поля **`КСписанию`** = остаток бонусных баллов

### Важно:
- **НЕ ИСПОЛЬЗУЕМ** формулу `Начислено - КСписанию`
- **ИСПОЛЬЗУЕМ** только значение `КСписанию` из последней записи
- Это поле показывает, сколько баллов доступно для списания (остаток)

### Реализация:
```python
params = {
    "$filter": f"{field_name} eq guid'{filter_value}'",
    "$top": 10000,
    "$orderby": "Period desc"
}
response = await client.get(url, params=params)
records = response.json().get("value", [])

if records:
    last_record = records[0]  # Самая свежая запись
    к_списанию = last_record.get("КСписанию") or 0
    balance = int(float(к_списанию))
```

## 3. Получение продаж по дисконтной карте

### Источник данных
- **Основной**: `AccumulationRegister_ПродажиПоДисконтнымКартам_RecordType`
- Фильтр: `ДисконтнаяКарта_Key eq guid'{card_key}'`
- **Fallback**: `AccumulationRegister_Продажи_RecordType`
- Фильтр: `Контрагент_Key eq guid'{customer_key}'`

### Важные поля:
- `Period` - дата покупки
- `Сумма` - сумма покупки
- `Количество` - количество товара
- `Номенклатура_Key` - ссылка на товар
- `Recorder` - ссылка на документ продажи
- `Recorder_Type` - тип документа (например, `Document_ВводНачальныхОстатков`)

## 4. Поиск документов переноса данных

### Типы документов:
- `Document_ВводНачальныхОстатков` ✅ (подтвержден)
- `Document_ВводОстатков`
- `Document_ПервоначальныеДанные`
- `Document_МиграцияДанных`
- `Document_ПереносДанных`

### Алгоритм поиска:
1. Ищем записи в `AccumulationRegister_ПродажиПоДисконтнымКартам_RecordType`
2. Проверяем `Recorder_Type` на `Document_ВводНачальныхОстатков`
3. **ВАЖНО**: Сумма переноса берется из поля `Сумма` записи регистра, а НЕ из самого документа
4. Получаем детали документа для информации (номер, дата)

### Пример:
```python
# В записи регистра:
{
    "Period": "2023-07-31T00:00:00",
    "Сумма": 232360.00,  # ← Это сумма переноса!
    "Recorder": "7f519352-bce5-11f0-9138-fa163e4cc04e",
    "Recorder_Type": "StandardODATA.Document_ВводНачальныхОстатков"
}
```

## 5. Связь товаров с каталогом GLAME

### Исключение упаковки
Не связываем с каталогом товары, содержащие в названии:
- мешочек, мешок, пакет, салфетка, коробка
- упаковка, конверт, футляр, чехол, обертка
- bag, box, pack, wrap, case, pouch

### Алгоритм связывания:
1. Получить `Номенклатура_Key` из записи продажи
2. Запросить товар из `Catalog_Номенклатура`
3. Извлечь `Code` (артикул) и `Description` (название)
4. Проверить, не является ли товар упаковкой
5. Искать в БД GLAME:
   - По `external_id` (приоритет 1)
   - По `article` или `external_code` (приоритет 2)

### Поля товара из 1С:
- `Ref_Key` - уникальный идентификатор
- `Code` - артикул (например, "НФ-00001238")
- `Description` - название
- `Наименование` - альтернативное поле названия
- `Артикул` - альтернативное поле артикула

## 6. Итоговая сумма покупок

### Формула:
```
Общая сумма = Сумма переноса + Сумма текущих продаж
```

Где:
- **Сумма переноса** = сумма из документа `ВводНачальныхОстатков` (из записи регистра)
- **Сумма текущих продаж** = сумма всех записей в `ПродажиПоДисконтнымКартам_RecordType` за период

## 7. Обновленные файлы

### Основной сервис синхронизации
- `backend/app/services/customer_sync_service.py`
  - ✅ Обновлен метод `_extract_customer_fields()` для извлечения города

### Сервис работы с 1С API
- `backend/app/services/onec_customers_service.py`
  - ✅ Уже правильно реализован `fetch_loyalty_balance()` с использованием `КСписанию`

### Тестовый скрипт
- `backend/test_customer_data.py`
  - ✅ Проверены все алгоритмы
  - ✅ Добавлен финальный вывод с итогами

## 8. Следующие шаги

1. ✅ Обновлена логика извлечения города в `customer_sync_service.py`
2. ⏳ Запустить полную синхронизацию покупателей
3. ⏳ Проверить обновление городов в БД
4. ⏳ Проверить корректность бонусных баллов
5. ⏳ Проверить суммы покупок

## 9. Команды для синхронизации

### Синхронизация всех данных покупателей
```bash
cd backend
# Запустить через API endpoint
curl -X POST http://localhost:8000/api/admin/onec/customers/sync/full \
  -H "Authorization: Bearer YOUR_TOKEN"
```

### Синхронизация только бонусных баллов
```bash
# Через API endpoint (если реализован)
curl -X POST http://localhost:8000/api/admin/onec/loyalty/sync \
  -H "Authorization: Bearer YOUR_TOKEN"
```

### Тестирование конкретного покупателя
```bash
cd backend
python test_customer_data.py --phone 79788451364
```

## Примечания

- Все алгоритмы проверены на реальных данных из 1С
- Приоритеты извлечения данных важны для корректной работы
- Обработка упаковки предотвращает загрязнение каталога
- Использование `КСписанию` подтверждено документацией 1С
