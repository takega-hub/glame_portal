# Загрузка характеристик товаров из 1С

## Обзор

Система поддерживает загрузку характеристик товаров из 1С УНФ ФРЕШ через каталог `Catalog_Номенклатура`. Характеристики автоматически извлекаются и сохраняются в поле `specifications` (JSON) в таблице `products`.

## Как это работает

### 1. Источник данных

Характеристики загружаются из коллекции:
- **`Catalog_Номенклатура`** - основной каталог товаров в 1С

### 2. Извлечение характеристик

Сервис `OneCProductsService` автоматически извлекает характеристики несколькими способами:

#### Способ 1: Прямые поля характеристик
Ищет поля с названиями:
- `specifications`
- `Характеристики`
- `Specifications`
- `ДополнительныеРеквизиты`
- `ДополнительныеРеквизитыИЗначения`
- `ХарактеристикиНоменклатуры`
- `СвойстваНоменклатуры`

#### Способ 2: Автоматический сбор всех полей
Собирает все поля из записи 1С, исключая:
- Служебные поля (ID, ключи, коды)
- Основную информацию (название, описание, цена)
- Изображения и теги
- Даты и статусы синхронизации

Все остальные поля автоматически добавляются в характеристики.

### 3. Сохранение в БД

Характеристики сохраняются в поле `specifications` типа JSON в таблице `products`:

```json
{
  "Материал": "Золото 585",
  "Размер": "18",
  "Вес": "2.5",
  "Проба": "585",
  "Камень": "Бриллиант",
  "Количество камней": "12",
  "ДополнительныеРеквизиты": {
    "Цвет": "Белый",
    "Стиль": "Классический"
  }
}
```

### 4. Полные данные из 1С

Все исходные данные из 1С также сохраняются в поле `onec_data` (JSON) для справки и дальнейшего анализа.

## Проверка доступных полей

Для проверки, какие поля доступны в `Catalog_Номенклатура`, запустите скрипт:

```bash
python backend/test_1c_nomenclature_fields.py
```

Скрипт:
1. Загружает несколько записей из каталога
2. Анализирует структуру полей
3. Группирует поля по категориям
4. Сохраняет полную структуру в `nomenclature_structure.json`

## Использование в коде

### Синхронизация товаров

```python
from app.services.onec_products_service import OneCProductsService
from app.database.connection import AsyncSessionLocal

async with AsyncSessionLocal() as db:
    async with OneCProductsService(db) as service:
        result = await service.sync_catalog(update_existing=True)
        # Характеристики автоматически извлекутся и сохранятся
```

### Получение характеристик товара

```python
from app.models.product import Product
from sqlalchemy import select

# Получаем товар
result = await db.execute(select(Product).where(Product.id == product_id))
product = result.scalar_one()

# Характеристики доступны в поле specifications
if product.specifications:
    material = product.specifications.get("Материал")
    size = product.specifications.get("Размер")
    # и т.д.
```

## Структура данных

### Поле specifications в БД

Тип: `JSONB` (PostgreSQL) / `JSON` (SQLAlchemy)

Формат: объект (словарь) с парами ключ-значение

Пример:
```json
{
  "Материал": "Золото 585",
  "Размер": "18",
  "Вес": "2.5 г",
  "Проба": "585",
  "Камень": "Бриллиант",
  "Количество камней": "12 шт",
  "Цвет": "Белый",
  "Стиль": "Классический",
  "Страна производства": "Россия"
}
```

### Поле onec_data в БД

Тип: `JSONB` (PostgreSQL) / `JSON` (SQLAlchemy)

Содержит полные исходные данные из 1С, включая все поля, даже те, которые не были извлечены как характеристики.

## API эндпоинты

### Синхронизация товаров

```
POST /api/onec/sync/products
```

Параметры:
- `update_existing` (bool, default: true) - обновлять существующие товары
- `full_sync` (bool, default: false) - полная синхронизация

Ответ:
```json
{
  "total": 150,
  "created": 10,
  "updated": 140,
  "errors": [],
  "error_count": 0
}
```

### Получение товара с характеристиками

```
GET /api/products/{id}
```

Ответ включает поле `specifications`:
```json
{
  "id": "uuid",
  "name": "Серьги AGafi",
  "specifications": {
    "Материал": "Золото 585",
    "Размер": "18"
  },
  ...
}
```

## Отображение на фронтенде

Характеристики доступны в объекте `Product`:

```typescript
interface Product {
  id: string;
  name: string;
  specifications?: Record<string, any>; // Характеристики из 1С
  // ...
}
```

Пример отображения:
```tsx
{product.specifications && (
  <div>
    <h3>Характеристики</h3>
    {Object.entries(product.specifications).map(([key, value]) => (
      <div key={key}>
        <strong>{key}:</strong> {String(value)}
      </div>
    ))}
  </div>
)}
```

## Улучшения

### Текущая реализация

✅ Автоматическое извлечение характеристик из прямых полей  
✅ Автоматический сбор всех полей как характеристик  
✅ Сохранение в структурированном JSON формате  
✅ Сохранение полных данных из 1С в `onec_data`

### Возможные улучшения

1. **Маппинг полей** - создать конфигурационный файл для маппинга полей 1С на понятные названия характеристик
2. **Валидация** - добавить валидацию характеристик перед сохранением
3. **Типизация** - определить типы для часто используемых характеристик
4. **Фильтрация** - добавить возможность исключать определенные поля из характеристик
5. **Группировка** - группировать характеристики по категориям (материал, размер, цвет и т.д.)

## Отладка

### Проверка загруженных характеристик

```sql
-- Посмотреть характеристики конкретного товара
SELECT id, name, specifications 
FROM products 
WHERE external_code = 'НФ-00002333';

-- Найти товары с характеристиками
SELECT id, name, specifications 
FROM products 
WHERE specifications IS NOT NULL 
  AND specifications != '{}'::jsonb;

-- Статистика по характеристикам
SELECT 
  COUNT(*) as total_products,
  COUNT(specifications) as products_with_specs,
  COUNT(*) FILTER (WHERE specifications IS NOT NULL AND specifications != '{}'::jsonb) as products_with_non_empty_specs
FROM products;
```

### Логирование

Сервис логирует процесс синхронизации:
- Количество загруженных товаров
- Количество созданных/обновленных записей
- Ошибки при синхронизации

Логи доступны в стандартном выводе и файлах логов приложения.

## Заключение

Система автоматически загружает характеристики товаров из 1С при синхронизации каталога. Характеристики сохраняются в структурированном формате JSON и доступны для использования в приложении.

Для проверки доступных полей используйте скрипт `test_1c_nomenclature_fields.py`.
